<Project>
  <!-- Custom targets that run after test execution -->

  <!-- Clean test output directories before running tests -->
  <Target Name="CleanTestOutputDirectories" BeforeTargets="VSTest" Condition="'$(IsTestProject)' == 'true'">
    <PropertyGroup>
      <TestResultsPath>$(MSBuildThisFileDirectory)artifacts\test-results</TestResultsPath>
      <LogsPath>$(MSBuildThisFileDirectory)artifacts\logs</LogsPath>
      <WatcherExePath>$(MSBuildThisFileDirectory)artifacts\bin\watcher\Debug\watcher.pid</WatcherExePath>
    </PropertyGroup>

    <!-- Use PowerShell for recursive deletion (handles long paths better than MSBuild) -->
    <Exec Command="powershell -NoProfile -Command &quot;if (Test-Path '$(TestResultsPath)') { Remove-Item -Path '$(TestResultsPath)' -Recurse -Force -ErrorAction SilentlyContinue }&quot;"
          Condition="Exists('$(TestResultsPath)')"
          ContinueOnError="true"
          IgnoreExitCode="true" />

    <!-- Recreate test-results directory structure -->
    <MakeDir Directories="$(TestResultsPath)\unit" />
    <MakeDir Directories="$(TestResultsPath)\e2e" />
    <Message Text="Recreated test-results directory structure" Importance="High" />

    <!-- Clean log files (preserve archives subdirectory) -->
    <ItemGroup>
      <LogFiles Include="$(LogsPath)\*.log" />
      <LogFiles Include="$(LogsPath)\internal-nlog.txt" />
    </ItemGroup>
    <Delete Files="@(LogFiles)" ContinueOnError="true" />
    <Message Text="Cleaned log files before running tests" Importance="High" Condition="Exists('$(LogsPath)')" />

    <!-- Delete watcher.pid if it exists -->
    <Delete Files="$(WatcherExePath)" Condition="Exists('$(WatcherExePath)')" />
    <Message Text="Cleaned watcher.pid file before running tests" Importance="High" Condition="Exists('$(WatcherExePath)')" />
  </Target>

  <!-- Generate coverage summary automatically after tests complete -->
  <Target Name="GenerateCoverageSummary" AfterTargets="VSTest" Condition="'$(IsTestProject)' == 'true'">
    <PropertyGroup>
      <!-- dotnet-coverage produces .coverage files (binary format) -->
      <CoverageFilesPattern>$(MSBuildThisFileDirectory)artifacts\test-results\**\*.coverage</CoverageFilesPattern>
      <MergedCoverageFile>$(MSBuildThisFileDirectory)artifacts\coverage-report\merged.coverage</MergedCoverageFile>
      <XmlCoverageFile>$(MSBuildThisFileDirectory)artifacts\coverage-report\coverage.xml</XmlCoverageFile>
      <CoverageOutputPath>$(MSBuildThisFileDirectory)artifacts\coverage-report</CoverageOutputPath>
    </PropertyGroup>

    <!-- Check if coverage files exist -->
    <ItemGroup>
      <CoverageFiles Include="$(CoverageFilesPattern)" />
    </ItemGroup>

    <!-- Step 1: Merge all .coverage files into single binary -->
    <Exec Command="dotnet-coverage merge &quot;$(CoverageFilesPattern)&quot; -o &quot;$(MergedCoverageFile)&quot;"
          Condition="'@(CoverageFiles)' != ''"
          ContinueOnError="true"
          IgnoreExitCode="false"
          ConsoleToMSBuild="true"
          StandardOutputImportance="Low" />

    <!-- Step 2: Convert binary .coverage to Visual Studio XML -->
    <Exec Command="dotnet-coverage merge &quot;$(MergedCoverageFile)&quot; -o &quot;$(XmlCoverageFile)&quot; -f xml"
          Condition="Exists('$(MergedCoverageFile)')"
          ContinueOnError="true"
          IgnoreExitCode="false"
          ConsoleToMSBuild="true"
          StandardOutputImportance="Low" />

    <!-- Step 3: Extract coverage summary using custom parser (avoids duplicate key issues) -->
    <Exec Command="dotnet run .build\extract-coverage-summary.cs &quot;$(XmlCoverageFile)&quot; &quot;$(CoverageOutputPath)\Summary.txt&quot;"
          Condition="Exists('$(XmlCoverageFile)')"
          ContinueOnError="true"
          IgnoreExitCode="false"
          ConsoleToMSBuild="true"
          StandardOutputImportance="Low"
          WorkingDirectory="$(MSBuildThisFileDirectory)" />

  </Target>

  <!-- Check for ungraceful shutdowns after test execution -->
  <Target Name="CheckUngracefulShutdowns" AfterTargets="GenerateCoverageSummary" Condition="'$(IsTestProject)' == 'true'">
    <PropertyGroup>
      <WatcherPidPath>$(MSBuildThisFileDirectory)artifacts\bin\watcher\Debug\watcher.pid</WatcherPidPath>
    </PropertyGroup>

    <!-- Read PIDs from file if it exists -->
    <ReadLinesFromFile File="$(WatcherPidPath)" Condition="Exists('$(WatcherPidPath)')">
      <Output TaskParameter="Lines" ItemName="OrphanedPids" />
    </ReadLinesFromFile>

    <!-- Emit warnings if watcher.pid exists (indicates ungraceful shutdown) -->
    <Message Text="WARNING: Ungraceful shutdown(s) detected!"
             Condition="Exists('$(WatcherPidPath)')"
             Importance="High" />

    <Message Text="WARNING: watcher.pid file still exists at: $(WatcherPidPath)"
             Condition="Exists('$(WatcherPidPath)')"
             Importance="High" />

    <Message Text="WARNING: Orphaned process IDs: @(OrphanedPids, ', ')"
             Condition="'@(OrphanedPids)' != ''"
             Importance="High" />
  </Target>

  <!-- Inspect test logs for warnings and errors (automated log inspection per CLAUDE.md) -->
  <Target Name="InspectTestLogs" AfterTargets="CheckUngracefulShutdowns" Condition="'$(IsTestProject)' == 'true'">
    <PropertyGroup>
      <LogsDirectory>artifacts/logs</LogsDirectory>
    </PropertyGroup>

    <!-- Run C# console app to check logs (only if logs directory exists) -->
    <Exec Command="dotnet run .build\check-test-logs.cs $(LogsDirectory)"
          Condition="Exists('$(MSBuildThisFileDirectory)$(LogsDirectory)')"
          ContinueOnError="true"
          IgnoreExitCode="false"
          ConsoleToMSBuild="false"
          StandardOutputImportance="High"
          StandardErrorImportance="High"
          WorkingDirectory="$(MSBuildThisFileDirectory)" />
  </Target>

  <!-- Analyze test execution times for slow tests (automated performance monitoring) -->
  <Target Name="AnalyzeTestExecutionTimes" AfterTargets="InspectTestLogs" Condition="'$(IsTestProject)' == 'true'">
    <PropertyGroup>
      <TrxDirectory>artifacts/test-results</TrxDirectory>
    </PropertyGroup>

    <!-- Run C# console app to analyze test times (only if TRX directory exists) -->
    <Exec Command="dotnet run .build\analyze-test-times.cs $(TrxDirectory)"
          Condition="Exists('$(MSBuildThisFileDirectory)$(TrxDirectory)')"
          ContinueOnError="true"
          IgnoreExitCode="false"
          ConsoleToMSBuild="false"
          StandardOutputImportance="High"
          StandardErrorImportance="High"
          WorkingDirectory="$(MSBuildThisFileDirectory)" />
  </Target>

  <!-- Display final code coverage summary (single line, only for last test project) -->
  <Target Name="DisplayCoverageSummary" AfterTargets="AnalyzeTestExecutionTimes" Condition="'$(IsTestProject)' == 'true' AND '$(MSBuildProjectName)' == 'e2e_tests'">
    <PropertyGroup>
      <CoverageSummaryFile>$(MSBuildThisFileDirectory)artifacts/coverage-report/Summary.txt</CoverageSummaryFile>
    </PropertyGroup>

    <!-- Run C# console app to display coverage summary (only once at the end) -->
    <!-- Capture output and echo via Message to ensure visibility at all verbosity levels -->
    <Exec Command="dotnet run .build\display-coverage-summary.cs $(CoverageSummaryFile)"
          Condition="Exists('$(CoverageSummaryFile)')"
          ContinueOnError="true"
          IgnoreExitCode="false"
          ConsoleToMSBuild="true"
          StandardOutputImportance="Low"
          WorkingDirectory="$(MSBuildThisFileDirectory)">
      <Output TaskParameter="ConsoleOutput" PropertyName="CoverageSummaryOutput" />
    </Exec>

    <!-- Echo captured output with High importance (shows at minimal verbosity and above) -->
    <Message Text="$(CoverageSummaryOutput)" Importance="high" Condition="'$(CoverageSummaryOutput)' != ''" />
  </Target>

  <!-- Clean artifacts directory when running 'dotnet clean' -->
  <Target Name="CleanArtifacts" BeforeTargets="Clean" Condition="'$(CleanArtifactsExecuted)' != 'true'">
    <PropertyGroup>
      <ArtifactsPath>$(MSBuildThisFileDirectory)artifacts</ArtifactsPath>
      <CleanArtifactsExecuted>true</CleanArtifactsExecuted>
    </PropertyGroup>

    <Message Text="Cleaning artifacts directory: $(ArtifactsPath)" Importance="High" Condition="Exists('$(ArtifactsPath)')" />

    <RemoveDir Directories="$(ArtifactsPath)" Condition="Exists('$(ArtifactsPath)')" />

    <Message Text="Artifacts directory has been removed" Importance="High" />
  </Target>

</Project>
